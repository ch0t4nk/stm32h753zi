/**
 * @file hardware_simulation.h
 * @brief Hardware simulation interface for safe development
 * @details Provides C interface to Python register simulation framework
 *
 * This header enables C code to interface with the Python simulation
 * framework for hardware-free testing and development.
 *
 * @note Part of STM32H753ZI stepper motor control project
 * @author Generated by Phase 1B simulation framework
 * @date 2025
 */

#ifndef HARDWARE_SIMULATION_H
#define HARDWARE_SIMULATION_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdint.h>

/* Simulation Configuration */
#define SIMULATION_ENABLED 1
#define MAX_SIMULATION_LOG 100

/* Simulation Mode Types */
typedef enum {
  SIM_MODE_STATIC = 0,      /**< Fixed register values */
  SIM_MODE_INTERACTIVE = 1, /**< Manual control via API */
  SIM_MODE_PHYSICS = 2,     /**< Motor physics simulation */
  SIM_MODE_PATTERN = 3      /**< Predefined motion patterns */
} simulation_mode_t;

/* Motor State Types */
typedef enum {
  MOTOR_STOPPED = 0,      /**< Motor not moving */
  MOTOR_ACCELERATING = 1, /**< Motor speeding up */
  MOTOR_RUNNING = 2,      /**< Motor at constant speed */
  MOTOR_DECELERATING = 3  /**< Motor slowing down */
} motor_state_t;

/* Simulation Status Structure */
typedef struct {
  /* L6470 Motor Status */
  int32_t motor_position;    /**< Current position in steps */
  float motor_speed;         /**< Current speed in steps/sec */
  motor_state_t motor_state; /**< Current motor state */
  int8_t motor_direction;    /**< 1 = forward, -1 = reverse */

  /* AS5600 Encoder Status */
  float encoder_angle;  /**< Current angle in degrees */
  uint16_t encoder_raw; /**< Raw 12-bit angle value */

  /* Simulation Control */
  bool linked_motion;     /**< Encoder follows motor */
  bool physics_active;    /**< Physics simulation running */
  uint32_t steps_per_rev; /**< Steps per revolution for linking */
} simulation_status_t;

/* Error Codes */
typedef enum {
  SIM_OK = 0,                   /**< Operation successful */
  SIM_ERROR_INVALID_ADDR = 1,   /**< Invalid register address */
  SIM_ERROR_READ_ONLY = 2,      /**< Attempted write to read-only register */
  SIM_ERROR_INVALID_VALUE = 3,  /**< Value outside valid range */
  SIM_ERROR_COMMAND_FAILED = 4, /**< Command execution failed */
  SIM_ERROR_NOT_INITIALIZED = 5 /**< Simulation not initialized */
} simulation_error_t;

/**
 * @brief Initialize hardware simulation
 * @param l6470_schema_path Path to L6470 register schema
 * @param as5600_schema_path Path to AS5600 register schema
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t simulation_init(const char *l6470_schema_path,
                                   const char *as5600_schema_path);

/**
 * @brief Cleanup and shutdown simulation
 */
void simulation_cleanup(void);

/**
 * @brief Read L6470 register
 * @param address Register address
 * @param value Pointer to store read value
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t l6470_sim_read_register(uint8_t address, uint32_t *value);

/**
 * @brief Write L6470 register
 * @param address Register address
 * @param value Value to write
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t l6470_sim_write_register(uint8_t address, uint32_t value);

/**
 * @brief Send L6470 command
 * @param command Command opcode
 * @param parameter Command parameter
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t l6470_sim_send_command(uint8_t command, uint32_t parameter);

/**
 * @brief Read AS5600 register
 * @param address Register address
 * @param value Pointer to store read value
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t as5600_sim_read_register(uint8_t address, uint16_t *value);

/**
 * @brief Write AS5600 register
 * @param address Register address
 * @param value Value to write
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t as5600_sim_write_register(uint8_t address, uint16_t value);

/**
 * @brief Get current simulation status
 * @param status Pointer to status structure
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t simulation_get_status(simulation_status_t *status);

/**
 * @brief Enable linked motion (encoder follows motor)
 * @param steps_per_revolution Steps per full revolution
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t
simulation_enable_linked_motion(uint32_t steps_per_revolution);

/**
 * @brief Disable linked motion
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t simulation_disable_linked_motion(void);

/**
 * @brief Start physics simulation
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t simulation_start_physics(void);

/**
 * @brief Stop physics simulation
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t simulation_stop_physics(void);

/**
 * @brief Set AS5600 angle pattern
 * @param pattern Pattern name ("static", "rotating", "sinusoidal")
 * @param speed Speed parameter (degrees/sec for rotating)
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t as5600_sim_set_pattern(const char *pattern, float speed);

/**
 * @brief Set AS5600 to specific angle
 * @param degrees Angle in degrees (0-360)
 * @return SIM_OK on success, error code otherwise
 */
simulation_error_t as5600_sim_set_angle(float degrees);

/* Simulation Macros for Driver Integration */
#if SIMULATION_ENABLED

/**
 * @brief Conditional compilation for simulation vs real hardware
 */
#define SIM_REGISTER_READ(chip, addr, value)                                   \
  do {                                                                         \
    if (chip##_sim_read_register((addr), (value)) != SIM_OK) {                 \
      /* Handle simulation error */                                            \
      *(value) = 0;                                                            \
    }                                                                          \
  } while (0)

#define SIM_REGISTER_WRITE(chip, addr, value)                                  \
  do {                                                                         \
    if (chip##_sim_write_register((addr), (value)) != SIM_OK) {                \
      /* Handle simulation error */                                            \
    }                                                                          \
  } while (0)

#define SIM_COMMAND_SEND(chip, cmd, param)                                     \
  do {                                                                         \
    if (chip##_sim_send_command((cmd), (param)) != SIM_OK) {                   \
      /* Handle simulation error */                                            \
    }                                                                          \
  } while (0)

#else
/* Real hardware macros would be defined here */
#define SIM_REGISTER_READ(chip, addr, value)  /* Real SPI read */
#define SIM_REGISTER_WRITE(chip, addr, value) /* Real SPI write */
#define SIM_COMMAND_SEND(chip, cmd, param)    /* Real SPI command */
#endif

#ifdef __cplusplus
}
#endif

#endif /* HARDWARE_SIMULATION_H */
