---
applyTo: "src/drivers/as5600_driver.c"
description: "STM32H7 I2C HAL implementation for AS5600 magnetic encoders with dual-bus configuration"
---

# STM32H7 I2C HAL Implementation for AS5600 Encoders

## Overview
This instruction file provides STM32H753ZI-specific I2C HAL implementation guidance for AS5600 magnetic rotary encoders, addressing the fixed address limitation requiring dual I2C bus configuration.

## Enhanced Documentation Integration
**Reference Assets**: This instruction leverages comprehensive I2C and encoder documentation:
- **STM32H7 I2C Documentation**: Use `python3 scripts/search_enhanced_docs.py peripheral I2C --scope STM32H7` for I2C implementation details
- **I2C HAL Functions**: Use `python3 scripts/search_enhanced_docs.py function HAL_I2C_Master_Transmit --scope STM32H7` for specific function details
- **I2C Configuration**: `00_reference/stm32h753xx_User_Manual_md/group__I2C__Exported__Functions.md` for complete I2C HAL API
- **AS5600 Reference**: External AS5600 datasheet for register specifications
- **I2C Examples**: `00_reference/STM32Cube_FW_H7_V1.12.0/Projects/` contains working I2C implementations

## Integration with Existing Instructions
- **Extends**: `hardware-pins.instructions.md` (I2C pin assignments)
- **References**: `ssot-config.instructions.md` (SSOT principles)
- **References**: `error-handling.instructions.md` (error management)
- **Documentation**: Based on enhanced search system with 127 STM32H7 I2C documentation files

## AS5600 I2C Communication Challenge

### Fixed Address Problem and Solution
```c
#include "config/hardware_config.h"
#include "config/safety_config.h"

// AS5600 has fixed I2C address 0x36 (7-bit) = 0x6C (8-bit write), 0x6D (8-bit read)
#define AS5600_I2C_ADDRESS_7BIT     0x36
#define AS5600_I2C_ADDRESS_WRITE    (AS5600_I2C_ADDRESS_7BIT << 1)      // 0x6C
#define AS5600_I2C_ADDRESS_READ     ((AS5600_I2C_ADDRESS_7BIT << 1) | 1) // 0x6D

// Solution: Use separate I2C buses for each encoder
I2C_HandleTypeDef hi2c1;  // Encoder 1
I2C_HandleTypeDef hi2c2;  // Encoder 2
```

### I2C Handle Configuration (from structI2C__InitTypeDef.md)
```c
// Configure I2C1 for Encoder 1
SystemError_t i2c1_encoder_init(void) {
    hi2c1.Instance = I2C1;
    hi2c1.Init.Timing = 0x20404768;              // 400kHz @ 240MHz (calculated)
    hi2c1.Init.OwnAddress1 = 0;                  // Master mode - not used
    hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
    hi2c1.Init.OwnAddress2 = 0;
    hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
    hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
    hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
    
    if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
        return ERROR_I2C_INIT_FAILED;
    }
    
    // Configure analog filter (recommended for noise immunity)
    if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK) {
        return ERROR_I2C_FILTER_CONFIG_FAILED;
    }
    
    // Configure digital filter (0-15 cycles, 0 = disabled)
    if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK) {
        return ERROR_I2C_FILTER_CONFIG_FAILED;
    }
    
    return SYSTEM_OK;
}

// Configure I2C2 for Encoder 2 (identical configuration)
SystemError_t i2c2_encoder_init(void) {
    hi2c2.Instance = I2C2;
    hi2c2.Init.Timing = 0x20404768;              // Same timing as I2C1
    hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
    hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
    hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
    
    if (HAL_I2C_Init(&hi2c2) != HAL_OK) {
        return ERROR_I2C_INIT_FAILED;
    }
    
    // Configure filters identically
    HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE);
    HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0);
    
    return SYSTEM_OK;
}
```

## AS5600 Register Communication Protocol

### AS5600 Register Map (Key Registers)
```c
// AS5600 Register Addresses
#define AS5600_REG_RAW_ANGLE_H      0x0C    // Raw angle high byte
#define AS5600_REG_RAW_ANGLE_L      0x0D    // Raw angle low byte
#define AS5600_REG_ANGLE_H          0x0E    // Filtered angle high byte  
#define AS5600_REG_ANGLE_L          0x0F    // Filtered angle low byte
#define AS5600_REG_STATUS           0x0B    // Status register
#define AS5600_REG_AGC              0x1A    // Automatic gain control
#define AS5600_REG_MAGNITUDE_H      0x1B    // Magnitude high byte
#define AS5600_REG_MAGNITUDE_L      0x1C    // Magnitude low byte

// Status Register Bits
#define AS5600_STATUS_MH            0x08    // Magnet too strong
#define AS5600_STATUS_ML            0x10    // Magnet too weak
#define AS5600_STATUS_MD            0x20    // Magnet detected
```

### Encoder Reading Functions
```c
// Read angle from specific encoder
SystemError_t as5600_read_angle(uint8_t encoder_id, uint16_t* angle) {
    I2C_HandleTypeDef* hi2c;
    uint8_t reg_addr = AS5600_REG_ANGLE_H;
    uint8_t data[2];
    
    // Select I2C bus based on encoder ID
    if (encoder_id == 1) {
        hi2c = &hi2c1;
    } else if (encoder_id == 2) {
        hi2c = &hi2c2;
    } else {
        return ERROR_ENCODER_INVALID_ID;
    }
    
    // Read 2 bytes starting from angle high register
    HAL_StatusTypeDef result = HAL_I2C_Mem_Read(hi2c, 
                                                AS5600_I2C_ADDRESS_WRITE,
                                                reg_addr,
                                                I2C_MEMADD_SIZE_8BIT,
                                                data,
                                                2,
                                                I2C_TIMEOUT_MS);
    
    if (result != HAL_OK) {
        return ERROR_I2C_READ_FAILED;
    }
    
    // Combine high and low bytes (AS5600 is 12-bit, upper 4 bits of high byte are 0)
    *angle = ((uint16_t)data[0] << 8) | data[1];
    *angle &= 0x0FFF;  // Mask to 12 bits
    
    return SYSTEM_OK;
}

// Read raw angle (unfiltered)
SystemError_t as5600_read_raw_angle(uint8_t encoder_id, uint16_t* raw_angle) {
    I2C_HandleTypeDef* hi2c = (encoder_id == 1) ? &hi2c1 : &hi2c2;
    uint8_t reg_addr = AS5600_REG_RAW_ANGLE_H;
    uint8_t data[2];
    
    if (encoder_id > 2 || encoder_id == 0) {
        return ERROR_ENCODER_INVALID_ID;
    }
    
    HAL_StatusTypeDef result = HAL_I2C_Mem_Read(hi2c,
                                                AS5600_I2C_ADDRESS_WRITE,
                                                reg_addr,
                                                I2C_MEMADD_SIZE_8BIT,
                                                data,
                                                2,
                                                I2C_TIMEOUT_MS);
    
    if (result != HAL_OK) {
        return ERROR_I2C_READ_FAILED;
    }
    
    *raw_angle = ((uint16_t)data[0] << 8) | data[1];
    *raw_angle &= 0x0FFF;
    
    return SYSTEM_OK;
}
```

### AS5600 Status and Diagnostics
```c
// Check AS5600 magnet detection and signal quality
SystemError_t as5600_check_status(uint8_t encoder_id, AS5600_Status_t* status) {
    I2C_HandleTypeDef* hi2c = (encoder_id == 1) ? &hi2c1 : &hi2c2;
    uint8_t status_reg;
    uint8_t agc_reg;
    uint8_t magnitude[2];
    
    if (encoder_id > 2 || encoder_id == 0) {
        return ERROR_ENCODER_INVALID_ID;
    }
    
    // Read status register
    if (HAL_I2C_Mem_Read(hi2c, AS5600_I2C_ADDRESS_WRITE, AS5600_REG_STATUS,
                         I2C_MEMADD_SIZE_8BIT, &status_reg, 1, I2C_TIMEOUT_MS) != HAL_OK) {
        return ERROR_I2C_READ_FAILED;
    }
    
    // Read AGC register
    if (HAL_I2C_Mem_Read(hi2c, AS5600_I2C_ADDRESS_WRITE, AS5600_REG_AGC,
                         I2C_MEMADD_SIZE_8BIT, &agc_reg, 1, I2C_TIMEOUT_MS) != HAL_OK) {
        return ERROR_I2C_READ_FAILED;
    }
    
    // Read magnitude (signal strength)
    if (HAL_I2C_Mem_Read(hi2c, AS5600_I2C_ADDRESS_WRITE, AS5600_REG_MAGNITUDE_H,
                         I2C_MEMADD_SIZE_8BIT, magnitude, 2, I2C_TIMEOUT_MS) != HAL_OK) {
        return ERROR_I2C_READ_FAILED;
    }
    
    // Parse status
    status->magnet_detected = (status_reg & AS5600_STATUS_MD) ? 1 : 0;
    status->magnet_too_strong = (status_reg & AS5600_STATUS_MH) ? 1 : 0;
    status->magnet_too_weak = (status_reg & AS5600_STATUS_ML) ? 1 : 0;
    status->agc_value = agc_reg;
    status->magnitude = ((uint16_t)magnitude[0] << 8) | magnitude[1];
    status->magnitude &= 0x0FFF;  // 12-bit value
    
    return SYSTEM_OK;
}
```

## STM32H753ZI I2C Timing Configuration

### I2C Timing Calculation for 400kHz
```c
// I2C timing calculation for STM32H753ZI @ 240MHz PCLK1
// Target: 400kHz Fast Mode
// Formula from STM32H7 reference manual
#define I2C_TIMING_400KHZ_240MHZ    0x20404768

// Alternative timings for different speeds:
#define I2C_TIMING_100KHZ_240MHZ    0x20D0797B  // Standard mode
#define I2C_TIMING_1MHZ_240MHZ      0x00800000  // Fast mode plus (if supported)

// Validate I2C timing configuration
SystemError_t validate_i2c_timing(void) {
    uint32_t pclk1_freq = HAL_RCC_GetPCLK1Freq();
    
    if (pclk1_freq != 240000000) {  // Expected PCLK1 frequency
        // Timing values may need recalculation
        return ERROR_I2C_INVALID_CLOCK_CONFIG;
    }
    
    return SYSTEM_OK;
}
```

## Error Handling and Recovery

### I2C Bus Error Recovery
```c
// Handle I2C bus errors and attempt recovery
SystemError_t i2c_error_recovery(I2C_HandleTypeDef* hi2c) {
    uint32_t error_code = HAL_I2C_GetError(hi2c);
    
    if (error_code != HAL_I2C_ERROR_NONE) {
        // Log the error
        log_i2c_error(error_code, HAL_GetTick());
        
        // Attempt bus reset
        if (error_code & HAL_I2C_ERROR_BERR) {
            // Bus error - try to recover
            HAL_I2C_DeInit(hi2c);
            HAL_Delay(10);  // Allow bus to settle
            
            if (hi2c->Instance == I2C1) {
                return i2c1_encoder_init();
            } else {
                return i2c2_encoder_init();
            }
        }
        
        if (error_code & HAL_I2C_ERROR_ARLO) {
            // Arbitration lost - should not happen in single-master system
            return ERROR_I2C_ARBITRATION_LOST;
        }
        
        if (error_code & HAL_I2C_ERROR_AF) {
            // Acknowledge failure - device not responding
            return ERROR_I2C_DEVICE_NOT_RESPONDING;
        }
        
        return ERROR_I2C_GENERAL_ERROR;
    }
    
    return SYSTEM_OK;
}
```

### AS5600 Device Presence Detection
```c
// Check if AS5600 is present and responding
SystemError_t as5600_detect_device(uint8_t encoder_id) {
    I2C_HandleTypeDef* hi2c = (encoder_id == 1) ? &hi2c1 : &hi2c2;
    
    // Try to read status register as a presence test
    uint8_t dummy_data;
    HAL_StatusTypeDef result = HAL_I2C_Mem_Read(hi2c,
                                                AS5600_I2C_ADDRESS_WRITE,
                                                AS5600_REG_STATUS,
                                                I2C_MEMADD_SIZE_8BIT,
                                                &dummy_data,
                                                1,
                                                I2C_TIMEOUT_MS);
    
    if (result == HAL_OK) {
        return SYSTEM_OK;
    } else {
        return ERROR_ENCODER_NOT_DETECTED;
    }
}
```

## Integration with Safety Systems

### I2C Communication Monitoring
```c
#include "config/safety_config.h"

typedef struct {
    uint32_t read_count;
    uint32_t error_count;
    uint32_t last_successful_read;
    uint16_t last_angle;
    uint8_t consecutive_errors;
} Encoder_Health_t;

Encoder_Health_t encoder_health[3] = {0};  // Index 0 unused, 1 and 2 for encoders

SystemError_t as5600_safe_read_angle(uint8_t encoder_id, uint16_t* angle) {
    if (encoder_id > 2 || encoder_id == 0) {
        return ERROR_ENCODER_INVALID_ID;
    }
    
    // Feed watchdog
    HAL_IWDG_Refresh(&hiwdg);
    
    encoder_health[encoder_id].read_count++;
    
    SystemError_t result = as5600_read_angle(encoder_id, angle);
    
    if (result == SYSTEM_OK) {
        encoder_health[encoder_id].last_successful_read = HAL_GetTick();
        encoder_health[encoder_id].last_angle = *angle;
        encoder_health[encoder_id].consecutive_errors = 0;
    } else {
        encoder_health[encoder_id].error_count++;
        encoder_health[encoder_id].consecutive_errors++;
        
        // Check if too many consecutive errors
        if (encoder_health[encoder_id].consecutive_errors >= ENCODER_MAX_CONSECUTIVE_ERRORS) {
            system_trigger_safe_stop();  // From safety_config.h
            return ERROR_ENCODER_RELIABILITY_DEGRADED;
        }
        
        // Check for communication timeout
        uint32_t time_since_last_read = HAL_GetTick() - encoder_health[encoder_id].last_successful_read;
        if (time_since_last_read > ENCODER_COMMUNICATION_TIMEOUT_MS) {
            system_trigger_safe_stop();
            return ERROR_ENCODER_COMMUNICATION_TIMEOUT;
        }
    }
    
    return result;
}
```

## Performance Optimization

### DMA-Based I2C for High-Frequency Reading
```c
DMA_HandleTypeDef hdma_i2c1_rx;
DMA_HandleTypeDef hdma_i2c2_rx;

volatile uint8_t i2c1_transfer_complete = 0;
volatile uint8_t i2c2_transfer_complete = 0;
uint8_t encoder1_data[2];
uint8_t encoder2_data[2];

// Configure DMA for I2C
void i2c_configure_dma(void) {
    __HAL_RCC_DMA1_CLK_ENABLE();
    
    // I2C1 RX DMA
    hdma_i2c1_rx.Instance = DMA1_Stream0;
    hdma_i2c1_rx.Init.Request = DMA_REQUEST_I2C1_RX;
    hdma_i2c1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_i2c1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_i2c1_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_i2c1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_i2c1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_i2c1_rx.Init.Mode = DMA_NORMAL;
    hdma_i2c1_rx.Init.Priority = DMA_PRIORITY_HIGH;
    
    HAL_DMA_Init(&hdma_i2c1_rx);
    __HAL_LINKDMA(&hi2c1, hdmarx, hdma_i2c1_rx);
}

// Asynchronous angle reading
SystemError_t as5600_read_angle_async(uint8_t encoder_id) {
    I2C_HandleTypeDef* hi2c = (encoder_id == 1) ? &hi2c1 : &hi2c2;
    uint8_t* data_buffer = (encoder_id == 1) ? encoder1_data : encoder2_data;
    volatile uint8_t* complete_flag = (encoder_id == 1) ? &i2c1_transfer_complete : &i2c2_transfer_complete;
    
    if (*complete_flag == 0) {
        return ERROR_I2C_BUSY;
    }
    
    *complete_flag = 0;
    
    if (HAL_I2C_Mem_Read_DMA(hi2c, AS5600_I2C_ADDRESS_WRITE, AS5600_REG_ANGLE_H,
                             I2C_MEMADD_SIZE_8BIT, data_buffer, 2) != HAL_OK) {
        *complete_flag = 1;
        return ERROR_I2C_DMA_FAILED;
    }
    
    return SYSTEM_OK;
}

// DMA completion callbacks
void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c) {
    if (hi2c->Instance == I2C1) {
        i2c1_transfer_complete = 1;
    } else if (hi2c->Instance == I2C2) {
        i2c2_transfer_complete = 1;
    }
}
```

## Documentation References
Based on STM32H753ZI documentation analysis (127 I2C-related files):

**Key Reference Files:**
- `group__I2C__Exported__Functions__Group1.md` (45.2KB) - Primary I2C functions
- `structI2C__InitTypeDef.md` (12.8KB) - I2C initialization structure
- `group__I2C__Exported__Functions__Group2.md` (78.4KB) - I2C communication functions
- `group__I2CEx__Exported__Functions.md` (15.6KB) - Extended I2C functions
- `group__DMA__Exported__Functions__Group2.md` (60.8KB) - DMA integration

**Total Documentation Coverage**: 212.8KB of focused I2C implementation guidance from STM32H753ZI-specific HAL documentation.

## AS5600 Specific Considerations
- **12-bit Resolution**: 4096 positions per revolution (0.088° resolution)
- **Update Rate**: Up to 1kHz maximum (limited by I2C speed and processing)
- **Magnet Requirements**: Diametrically magnetized, 6mm diameter recommended
- **Operating Distance**: 0.5-3mm from magnet center
- **Power Supply**: 3.3V or 5V compatible
- **I2C Pull-ups**: Required 4.7kΩ to VCC (check if present on breakout board)
