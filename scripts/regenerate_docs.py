"""Regenerate domain docs driven by SSOT and archived docs.

Behavior:
- Load SSOT anchors from `src/config/ssot.yaml` if present (optional)
- Ingest `STATUS.md` for context
- For each domain file listed below, regenerate a template with last_updated and a short summary
- Optionally use archived docs in `archive/outdated_docs/DOCS_BKUP_08-18-2025` as historical reference
- Validate SSOT via `scripts/validate_ssot.py` (callable)
- If changes are present, stage and commit them with the configured message

This script is intentionally simple and deterministic so it can run inside GitHub Actions without external LLM calls.
"""
from __future__ import annotations
import os
import sys
import subprocess
from datetime import datetime
from pathlib import Path
import argparse

ROOT = Path(__file__).resolve().parent.parent
DOCS_DIR = ROOT / 'docs'
ARCHIVE_DIR = ROOT / 'archive' / 'outdated_docs' / 'DOCS_BKUP_08-18-2025'
SSOT_PATH = ROOT / 'src' / 'config' / 'ssot.yaml'
STATUS_MD = ROOT / 'STATUS.md'

DOMAIN_FILES = [
    'core_software.md',
    'communications.md',
    'telemetry.md',
    'motor_control.md',
    'safety.md',
    'build_testing.md',
    'documentation_ssot.md',
]

COMMIT_MSG = 'docs: regenerate domain docs via Copilot++ offload'


def run(cmd, check=True, capture=False):
    print(f">>> {cmd}")
    res = subprocess.run(cmd, shell=True, check=False, capture_output=capture, text=True)
    if check and res.returncode != 0:
        print(res.stdout)
        print(res.stderr, file=sys.stderr)
        raise SystemExit(res.returncode)
    return res


def read_status():
    if not STATUS_MD.exists():
        return None
    return STATUS_MD.read_text(encoding='utf-8')


def load_ssot():
    if not SSOT_PATH.exists():
        return None
    try:
        import yaml
    except Exception:
        return None
    with open(SSOT_PATH, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)


def generate_doc(filename: str, status_text: str | None, ssot: dict | None):
    now = datetime.utcnow().strftime('%Y-%m-%d')
    path = DOCS_DIR / filename
    header = f"# {filename.replace('_', ' ').replace('.md', '').title()}\nlast_updated: {now}\nssot: {SSOT_PATH.relative_to(ROOT)}\n\n"
    body = ''
    # Prefer archived version if present for historical continuity
    archived = ARCHIVE_DIR / filename
    if archived.exists():
        body += f"<!-- archived content preserved from {ARCHIVE_DIR.relative_to(ROOT)} -->\n\n"
        body += archived.read_text(encoding='utf-8') + '\n\n'
    # Fallback template
    body += f"## Domain\nShort summary: autogenerated placeholder for {filename}\n\n"
    body += "### Subsystems\n- TODO: populate subsystem list from source code and SSOT\n\n"
    body += "### AI Handoff\n- Include semantic anchors and reference SSOT for canonical parameters.\n\n"
    # Simple mermaid placeholder
    body += "```mermaid\nflowchart TD\n  A[Start] --> B[Work]\n  B --> C[Done]\n```\n"
    path.parent.mkdir(parents=True, exist_ok=True)
    new_content = header + body
    if path.exists():
        try:
            old = path.read_text(encoding='utf-8')
        except Exception:
            old = None
        if old == new_content:
            return path, False
    path.write_text(new_content, encoding='utf-8')
    return path, True


def validate_ssot():
    script = ROOT / 'scripts' / 'validate_ssot.py'
    if not script.exists():
        print('SSOT validation script not found, skipping validation')
        return True
    res = run(f"python {script}", check=False, capture=True)
    print(res.stdout)
    if res.returncode != 0:
        print('SSOT validation failed', file=sys.stderr)
        return False
    return True


def main(argv=None):
    parser = argparse.ArgumentParser()
    parser.add_argument('--commit', action='store_true', help='Stage and commit regenerated docs')
    parser.add_argument('--status-only', action='store_true', help='Do not write files, only report what would change')
    parser.add_argument('--require-ssot', action='store_true', help='Fail the run if SSOT validation fails')
    args = parser.parse_args(argv)

    status_text = read_status()
    ssot = load_ssot()

    print('Generating domain docs...')
    changed = False
    for f in DOMAIN_FILES:
        path = DOCS_DIR / f
        # If status-only, we only report whether it would be created/changed
        if args.status_only:
            would_create = not path.exists()
            print(f"Would create {f}: {would_create}")
            continue
        new_path, did_change = generate_doc(f, status_text, ssot)
        if did_change:
            print(f'Wrote {new_path}')
            changed = True
        else:
            print(f'No change for {new_path}')

    # Run SSOT validation
    ok = validate_ssot()
    if not ok:
        print('Warning: SSOT validation failed', file=sys.stderr)
        if args.require_ssot:
            print('SSOT validation required; aborting', file=sys.stderr)
            raise SystemExit(2)

    if args.commit and changed:
        print('Staging changes...')
        run('git add docs .copilot-tasks .github/workflows', check=True)
        print('Committing...')
        run(f'git commit -m "{COMMIT_MSG}"', check=False)
        print('Commit complete')
    else:
        print('No commit requested or no changes found')


if __name__ == '__main__':
    main()
